shared_examples_for 'Msf::Exploit::Payload::Nop' do
  shared_context 'compatible_nop_instances' do
    #
    # Methods
    #

    def update_compatibility(module_instance)
      module_architecture = module_instance.module_architectures.build
      module_architecture.architecture = compatible_architecture

      Metasploit::Model::Module::Instance::Spec::Template.write!(module_instance: module_instance)

      module_instance.save!
    end

    #
    # lets
    #

    let(:cache_nop_classes) do
      FactoryGirl.create_list(
          :mdm_module_class,
          2,
          module_type: 'nop'
      # sort in ASC, then reverse to make DESC to make ranked scope
      ).sort_by { |module_class|
        module_class.rank.number
      }.reverse
    end

    let(:cache_payload_class) do
      FactoryGirl.create(
          :mdm_module_class,
          module_type: 'payload'
      )
    end

    let(:compatible_architecture) do
      FactoryGirl.generate :mdm_architecture
    end

    let(:payload_instance) do
      # have to use cache_payload_instance.module_class to ensure that instance is created before class
      framework.modules.create_from_module_class(cache_payload_instance.module_class)
    end

    #
    # let!s
    #

    let!(:cache_nop_instances) do
      cache_nop_classes.collect { |cache_nop_class|
        FactoryGirl.build(
            :mdm_module_instance,
            module_architectures_length: 0,
            module_class: cache_nop_class
        ).tap { |module_instance|
          update_compatibility(module_instance)
        }
      }
    end

    let!(:cache_payload_instance) do
      FactoryGirl.build(
          :mdm_module_instance,
          module_architectures_length: 0,
          module_class: cache_payload_class
      ).tap { |module_instance|
        update_compatibility(module_instance)
      }
    end
  end

  context '#make_nops' do
    subject(:make_nops) do
      exploit_instance.make_nops(count)
    end

    let(:count) do
      1
    end

    context 'with debugging' do
      before(:each) do
        exploit_instance.data_store['DEBUG'] = 'y'
      end

      it 'should return all 0x90s' do
        expect(make_nops.length).to be(count)
        expect(make_nops).to match(/\A\x90\Z/)
      end
    end

    context 'without debugging' do
      before(:each) do
        exploit_instance.payload_instance = payload_instance
      end

      context 'with payload_instance' do
        include_context 'compatible_nop_instances'

        it 'calls compatible_nop_instances' do
          expect(payload_instance).to receive(:compatible_nop_instances).and_call_original

          make_nops
        end

        context 'compatible_nop_instances' do
          context 'with error' do
            #
            # lets
            #

            let(:cache_nop_class_with_error) do
              cache_nop_classes.first
            end

            let(:cache_nop_class_without_error) do
              cache_nop_classes.last
            end

            let(:error) do
              StandardError.new
            end

            let(:nop_class_with_error) do
              framework.modules.cache.metasploit_class(cache_nop_class_with_error)
            end

            let(:nop_class_without_error) do
              framework.modules.cache.metasploit_class(cache_nop_class_without_error)
            end

            let(:nop_instance_without_error) do
              nop_class_without_error.new(framework: framework)
            end

            let(:nop_instance_without_error_nop_sled) do
              nop_instance_without_error.generate_sled(
                  count,
                  'BadChars' => exploit_instance.payload_badchars,
                  'SaveRegisters' => exploit_instance.nop_save_registers
              )
            end

            #
            # Callbacks
            #

            before(:each) do
              error = self.error
              method_with_error = self.method_with_error

              nop_class_with_error.class_eval do
                define_method(method_with_error) do |*args, &block|
                  raise error
                end
              end
            end

            context 'from copy_ui' do
              let(:method_with_error) do
                :copy_ui
              end

              it 'logs error' do
                expect(exploit_instance).to receive(:elog)

                make_nops
              end

              it 'uses nop sled from nop_instance without error' do
                expect(make_nops).to equal(nop_instance_without_error_nop_sled)
              end
            end

            context 'from generate_sled' do
              #
              # lets
              #

              let(:method_with_error) do
                :generate_sled
              end

              it 'logs error' do
                expect(exploit_instance).to receive(:elog)

                make_nops
              end

              it 'uses nop sled from nop_instance without error' do
                expect(make_nops).to equal(nop_instance_without_error_nop_sled)
              end
            end
          end

          context 'without error' do
            let(:cache_nop_class) do
              cache_nop_classes.first
            end

            let(:nop_instance) do
              framework.modules.create_from_module_class(cache_nop_class)
            end

            let(:nop_sled) do
              nop_instance.generate_sled(
                  count,
                  'BadChars' => exploit_instance.payload_badchars,
                  'SaveRegisters' => exploit_instance.nop_save_registers
              )
            end


            let(:nop_class) do
              framework.modules.cache.metasploit_class(cache_nop_class)
            end

            it 'uses nop sled from nop_instance without error' do
              expect(make_nops).to equal(nop_sled)
            end
          end
        end
      end

      context 'without #payload_instance' do
        let(:payload_instance) do
          nil
        end

        it { should be_nil }
      end
    end
  end

  context '#nop_generator' do
    subject(:nop_generator) do
      exploit_instance.nop_generator
    end

    before(:each) do
      exploit_instance.payload_instance = payload_instance
    end

    context 'with payload_instance' do
      include_context 'compatible_nop_instances'

      let(:cache_nop_class) do
        cache_nop_classes.first
      end

      let(:nop_class) do
        framework.modules.cache.metasploit_class(cache_nop_class)
      end

      it 'should be the first compatible nop instance' do
        expect(nop_generator).to be_a nop_class
      end
    end

    context 'without payload_instance' do
      let(:payload_instance) do
        nil
      end

      it { should be_nil }
    end
  end
end