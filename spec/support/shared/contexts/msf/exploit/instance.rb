shared_context 'Msf::Exploit metasploit_instance' do
  include_context 'Metasploit::Framework::Spec::Constants cleaner'
  include_context 'Msf::Simple::Framework'
  include_context 'database cleaner'

  let(:metasploit_class) do
    # exploits only have one metasploit_class
    metasploit_module.each_metasploit_class.first
  end

  let(:metasploit_instance) do
    metasploit_class.new(framework: framework)
  end

  let(:metasploit_module) do
    module_ancestor_load.metasploit_module
  end

  let(:module_ancestor) do
    module_path.module_ancestors.new(real_path: module_ancestor_real_path)
  end

  let(:module_ancestor_load) do
    Metasploit::Framework::Module::Ancestor::Load.new(module_ancestor: module_ancestor)
  end

  let(:module_ancestor_real_path) do
    module_ancestor_real_paths.sample
  end

  let(:module_ancestor_real_paths) do
    File::Find.new(
        ftype: 'file',
        path: File.join(module_path.real_path, 'exploits'),
        pattern: "*#{Metasploit::Model::Module::Ancestor::EXTENSION}"
    ).find
  end

  let(:module_path) do
    FactoryGirl.create(
        :mdm_module_path,
        gem: 'metasploit-framework',
        name: 'modules',
        real_path: Metasploit::Framework.root.join('modules').to_path
    )
  end

  #
  # Callbacks
  #

  before(:each) do
    framework.cache.write_module_ancestor_load(module_ancestor_load)
  end
end