require 'spec_helper'

describe Metasploit::Framework::Command::Exploit do
  include_context 'Msf::Ui::Console::Driver'
  include_context 'Msf::Ui::Console::Driver#metasploit_instance'

  #
  # Shared examples
  #

  shared_examples_for 'delegates to #dispatcher' do |method|
    context "##{method}" do
      subject do
        command.send(method)
      end

      context "with #dispatcher" do
        it 'delegates to #dispatcher' do
          expected = double(method)
          expect(dispatcher).to receive(method).and_return(expected)
          expect(subject).to eq(expected)
        end
      end

      context 'without #dispatcher' do
        let(:dispatcher) do
          nil
        end

        it { should be_nil }
      end
    end
  end

  subject(:command) do
    described_class.new(
        dispatcher: dispatcher,
        partial_word: partial_word,
        words: words
    )
  end

  #
  # lets
  #

  let(:dispatcher) do
    Msf::Ui::Console::CommandDispatcher::Core.new(msf_ui_console_driver)
  end

  let(:partial_word) do
    nil
  end

  let(:words) do
    []
  end

  it_should_behave_like 'Metasploit::Framework::Command::Parent'

  context 'description' do
    subject(:description) do
      described_class.description
    end

    it { should == 'Launch an exploit attempt' }
  end

  context 'subcommands' do
    it { should have_subcommand(:help).class_name('Metasploit::Framework::Command::Exploit::Help') }
    it { should have_subcommand(:simple).class_name('Metasploit::Framework::Command::Exploit::Simple').default(true) }
  end

  it_should_behave_like 'delegates to #dispatcher', :framework
  it_should_behave_like 'delegates to #dispatcher', :metasploit_instance

  context '#option_parser' do
    subject(:option_parser) do
      command.option_parser
    end

    context 'banner' do
      subject(:banner) do
        option_parser.banner
      end

      it { should == 'Usage: exploit [options]' }
    end
  end

  context '#parse_words' do
    shared_examples_for 'boolean' do |attribute, options={}|
      options.assert_valid_keys(:short_option_name)

      context attribute do
        short_option_name = options.fetch(:short_option_name, "-#{attribute.to_s[0,1]}")

        context "with short_option_name" do
          let(:words) do
            [
                short_option_name
            ]
          end
          
          it "set #{attribute} to true on :simple subcommand" do
            expect {
              parse_words
            }.to change(simple_subcommand, attribute).to(true)
          end
        end

        long_option_name = "--#{attribute}"

        context "with #{long_option_name}" do
          let(:words) do
            [
                long_option_name
            ]
          end

          it "set #{attribute} to true on :simple subcommand" do
            expect {
              parse_words
            }.to change(simple_subcommand, attribute).to(true)
          end
        end

        negation_option_name = "--no-#{attribute}"

        context "with #{negation_option_name}" do
          #
          # lets
          #

          let(:words) do
            [
                negation_option_name
            ]
          end

          #
          # Callbacks
          #

          before(:each) do
            simple_subcommand.send("#{attribute}=", true)
          end

          it "set #{attribute} to false on :simple subcommand" do
            expect {
              parse_words
            }.to change(simple_subcommand, attribute).to(false)
          end
        end
      end
    end
    
    shared_examples_for 'module_class_reference_name_option' do |options={}|
      options.assert_valid_keys(:attribute, :long_option_name, :module_type, :short_option_name)

      attribute = options.fetch(:attribute)
      long_option_name = options.fetch(:long_option_name)
      module_type = options.fetch(:module_type)
      short_option_name = options.fetch(:short_option_name)

      context "for module_type #{module_type}" do
        let(:module_type_class_reference_name) do
          'module/type/class/reference/name'
        end
        
        let(:words) do
          [
              option_name,
              module_type_class_reference_name
          ]
        end
        
        context "with #{short_option_name}" do
          let(:option_name) do
            short_option_name
          end
          
          it "sets #{attribute} on :simple subcommand" do
            expect {
              parse_words
            }.to change(simple_subcommand, attribute).to(module_type_class_reference_name)
          end
        end
        
        context "with #{long_option_name}" do
          let(:option_name) do
            long_option_name
          end

          it "sets #{attribute} on :simple subcommand" do
            expect {
              parse_words
            }.to change(simple_subcommand, attribute).to(module_type_class_reference_name)
          end
        end
      end
    end

    subject(:parse_words) do
      command.send(:parse_words)
    end

    let(:simple_subcommand) do
      command.send(:subcommand_by_name)[:simple]
    end

    it 'should pass duplicate of #words to option_parser to parse' do
      command.option_parser.should_receive(:parse!) { |parsed_words|
        parsed_words.should_not be command.words
        parsed_words.should == command.words
      }.and_return([])

      parse_words
    end

    it_should_behave_like 'boolean',
                          :background,
                          short_option_name: '-z'

    it_should_behave_like 'module_class_reference_name_option',
                          attribute: :encoder_class_reference_name,
                          long_option_name: '--encoder-class-reference-name',
                          module_type: 'encoder',
                          short_option_name: '-e'

    it_should_behave_like 'boolean', :force
    it_should_behave_like 'boolean', :job

    context 'options' do
      context 'with no variable=value pairs' do
        let(:words) do
          [
              '--options'
          ]
        end

        it 'should set #options on :simple subcommand to an empty Hash' do
          parse_words

          expect(simple_subcommand.options).to eq({})
        end
      end

      context 'with one variable=value pair' do
        let(:value) do
          'VAL1'
        end

        let(:variable) do
          'VAR1'
        end

        let(:words) do
          [
              '--options',
              "#{variable}=#{value}"
          ]
        end

        it 'should set #options to Hash of variable => value pair' do
          parse_words

          expect(simple_subcommand.options).to eq(
                                                                     {
                                                                         variable => value
                                                                     }
                                                                 )
        end
      end

      context 'with multiple variable=value pairs' do
        let(:expected) do
          {
              'VAR1' => 'VAL1',
              'VAR2' => 'VAL2'
          }
        end

        let(:pairs) do
          expected.collect { |variable, value|
            "#{variable}=#{value}"
          }
        end

        let(:words) do
          [
              '--options',
              pairs.join(',')
          ]
        end

        it 'should set #options to Hash of all variable => value pairs' do
          parse_words

          expect(simple_subcommand.options).to eq(expected)
        end
      end
    end

    it_should_behave_like 'module_class_reference_name_option',
                          attribute: :nop_class_reference_name,
                          long_option_name: '--nop-class-reference-name',
                          module_type: 'nop',
                          short_option_name: '-n'
    it_should_behave_like 'module_class_reference_name_option',
                          attribute: :payload_class_reference_name,
                          long_option_name: '--payload-class-reference-name',
                          module_type: 'payload',
                          short_option_name: '-p'

    context 'target_name' do
      let(:target_name) do
        'Named Target'
      end

      let(:words) do
        [
            option_name,
            target_name
        ]
      end

      context 'with -t' do
        let(:option_name) do
          '-t'
        end

        it 'sets #target_name on :simple subcommand' do
          expect {
            parse_words
          }.to change(simple_subcommand, :target_name).to(target_name)
        end
      end

      context 'with --target-name' do
        let(:option_name) do
          '--target-name'
        end

        it 'sets #target_name on :simple subcommand' do
          expect {
            parse_words
          }.to change(simple_subcommand, :target_name).to(target_name)
        end
      end
    end
  end
end