require 'spec_helper'

describe Metasploit::Framework::Command::Exploit::Simple do
  include_context 'Msf::Ui::Console::Driver'
  include_context 'Msf::Ui::Console::Driver#metasploit_instance'
  include_context 'output'

  #
  # Shared Examples
  #

  shared_examples_for 'delegates to #metasploit_instance' do |method|
    context "##{method}" do
      # no let name so that it doesn't interfere with outer lets
      subject do
        command.send(method)
      end

      context 'with #metasploit_instance' do
        it "uses ##{method} on #metasploit_instance" do
          expected = double(method)
          expect(metasploit_instance).to receive(method).and_return(expected)

          expect(subject).to eq(expected)
        end
      end

      context 'without #metasploit_instance' do
        let(:metasploit_instance) do
          nil
        end

        it 'does not raise error' do
          expect {
            subject
          }.not_to raise_error
        end
      end
    end
  end

  subject(:command) do
    described_class.new(
        parent: parent
    )
  end

  #
  # lets
  #

  let(:dispatcher) do
    Msf::Ui::Console::CommandDispatcher::Core.new(msf_ui_console_driver)
  end

  let(:parent) do
    Metasploit::Framework::Command::Exploit.new(
        dispatcher: dispatcher,
        partial_word: partial_word,
        words: words
    )
  end

  let(:partial_word) do
    nil
  end

  let(:words) do
    []
  end

  it_should_behave_like 'Metasploit::Framework::Command::Child'

  context 'validations' do
    context 'dispatcher' do
      it_should_behave_like 'validates Metasploit::Framework::Command#dispatcher is fanged'
    end

    context 'metasploit_instance' do
      it_should_behave_like 'validates presence of Metasploit::Framework::Command#metasploit_instance'
    end

    context 'rank_number' do
      subject(:rank_number_errors) do
        command.errors[:rank_number]
      end

      #
      # lets
      #

      let(:error) do
        I18n.translate!(
            'metasploit.model.errors.models.metasploit/framework/command/exploit/simple.attributes.rank_number.minimum_rank',
            minimum_rank_name: minimum_rank_name,
            minimum_rank_number: minimum_rank_number,
            rank_name: rank_name,
            rank_number: rank_number
        )
      end

      let(:minimum_rank_name) do
        Metasploit::Model::Module::Rank::NAME_BY_NUMBER[minimum_rank_number]
      end

      let(:rank_name) do
        Metasploit::Model::Module::Rank::NAME_BY_NUMBER[rank_number]
      end

      context '#minimum_rank_or_forced' do
        before(:each) do
          allow(command).to receive(:force).and_return(force)
          allow(command).to receive(:minimum_rank_number).and_return(minimum_rank_number)
          allow(command).to receive(:rank_number).and_return(rank_number)

          command.valid?
        end

        context 'with rank_number' do
          let(:rank_number) do
            500
          end

          context '< minimum_rank_number' do
            let(:minimum_rank_number) do
              600
            end

            context 'with forced' do
              let(:force) do
                true
              end

              it { should_not include(error) }
            end

            context 'without forced' do
              let(:force) do
                false
              end

              it { should include(error) }
            end
          end

          context '== minimum_rank_number' do
            let(:minimum_rank_number) do
              500
            end

            context 'with forced' do
              let(:force) do
                true
              end

              it { should_not include(error) }
            end

            context 'without forced' do
              let(:force) do
                false
              end

              it { should_not include(error) }
            end
          end

          context '> minimum_rank_number' do
            let(:minimum_rank_number) do
              400
            end

            context 'with forced' do
              let(:force) do
                true
              end

              it { should_not include(error) }
            end

            context 'without forced' do
              let(:force) do
                false
              end

              it { should_not include(error) }
            end
          end
        end

        context 'without rank_number' do
          let(:force) do
            [false, true].sample
          end

          let(:minimum_rank_number) do
            Metasploit::Model::Module::Rank::NAME_BY_NUMBER.keys.sample
          end

          let(:rank_number) do
            nil
          end

          it { should_not include(error) }
        end
      end
    end

    context 'module_type' do
      subject(:module_type_errors) do
        command.errors[:module_type]
      end

      #
      # lets
      #

      let(:error) do
        I18n.translate('errors.messages.inclusion')
      end

      #
      # Callbacks
      #

      before(:each) do
        allow(command).to receive(:module_type).and_return(module_type)

        command.valid?
      end

      context 'with exploit' do
        let(:module_type) do
          'exploit'
        end

        it 'does not add error on :module_type' do
          expect(module_type_errors).not_to include(error)
        end
      end

      context 'without exploit' do
        let(:module_type) do
          Metasploit::Model::Module::Type::ALL - ['exploit']
        end

        it 'adds error on :module_type' do
          expect(module_type_errors).to include(error)
        end
      end
    end

    context 'words' do
      subject(:words_errors) do
        command.errors[:words]
      end

      #
      # lets
      #

      let(:error) do
        I18n.translate!('errors.messages.wrong_length', count: 0)
      end

      #
      # Callbacks
      #

      before(:each) do
        command.valid?
      end

      context 'with words' do
        let(:words) do
          [
              'ignored',
              'words'
          ]
        end

        it 'adds error to :words' do
          expect(words_errors).to include(error)
        end
      end

      context 'without words' do
        let(:words) do
          []
        end

        it 'does not add error to :words' do
          expect(words_errors).not_to include(error)
        end
      end
    end
  end

  context 'background' do
    subject(:background) do
      command.background
    end

    context 'default' do
      it { should be_false }
    end
  end

  context 'background?' do
    subject(:background?) do
      command.background?
    end

    context 'default' do
      it { should be_false }
    end
  end

  context '#default_payload_class_reference_name' do
    subject(:default_payload_class_reference_name) do
      command.send(:default_payload_class_reference_name)
    end

    context 'with #payload_compatibility' do
      it 'uses #preferred_class_reference_name on #payload_compatibility' do
        expected = double('#preferred_class_reference_name')
        expect(command.send(:payload_compatibility)).to receive(:preferred_class_reference_name).and_return(expected)
        expect(default_payload_class_reference_name).to eq(expected)
      end
    end

    context 'without #payload_compatibility' do
      before(:each) do
        allow(command).to receive(:payload_compatibility).and_return(nil)
      end

      it { should be_nil }
    end
  end

  context '#encoder_class_reference_name' do
    subject(:encoder_class_reference_name) do
      command.encoder_class_reference_name
    end

    before(:each) do
      metasploit_instance.datastore['ENCODER'] = encoder
    end

    context 'with ENCODER' do
      let(:encoder) do
        'encoder/class/reference/name'
      end

      it 'is ENCODER' do

      end
    end

    context 'without ENCODER' do
      let(:encoder) do
        nil
      end

      it { should be_nil }
    end
  end

  context '#force' do
    subject(:force) do
      command.force
    end

    context 'default' do
      it { should be_false }
    end
  end

  context '#force?' do
    subject(:force?) do
      command.force?
    end

    context 'default' do
      it { should be_false }
    end
  end

  it_should_behave_like 'Metasploit::Framework::Command::Child delegates to #parent', :framework

  context '#job' do
    subject(:job) do
      command.job
    end

    context 'with #metasploit_instance' do
      context 'responds to passive?' do
        before(:each) do
          allow(metasploit_instance).to receive(:passive?).and_return(passive)
        end

        context 'with true' do
          let(:passive) do
            true
          end
        end

        context 'with false' do
          let(:passive) do
            false
          end

          it { should be false }
        end
      end

      context 'does not respond passive?' do
        before(:each) do
          class << metasploit_instance
            undef_method :passive?
          end
        end

        it { should be_false }
      end
    end

    context 'without #metasploit_instance' do
      let(:metasploit_instance) do
        nil
      end

      it { should be_false }
    end
  end

  context '#job?' do
    subject(:job?) do
      command.job?
    end

    it 'delegates to #job' do
      expect(command).to receive(:job)

      job?
    end

    context 'with non-Boolean from #job' do
      #
      # lets
      #

      let(:non_boolean) do
        nil
      end

      #
      # Callbacks
      #

      before(:each) do
        allow(command).to receive(:job).and_return(non_boolean)
      end

      it 'returns Boolean' do
        expect(job?).to eq(false)
      end
    end
  end

  it_should_behave_like 'Metasploit::Framework::Command::Child delegates to #parent', :metasploit_instance

  context '#minimum_rank_number' do
    subject(:minimum_rank_number) do
      command.send(:minimum_rank_number)
    end

    context 'with #framework' do
      before(:each) do
        framework.datastore['MinimumRank'] = minimum_rank
      end

      context 'with MinimumRank' do
        context 'with valid Metasploit::Model::Module::Rank#name' do
          let(:minimum_rank) do
            FactoryGirl.generate :metasploit_model_module_rank_name
          end

          it 'equal the corresponding rank number' do
            expect(minimum_rank_number).to eq(Metasploit::Model::Module::Rank::NUMBER_BY_NAME.fetch(minimum_rank))
          end
        end

        context 'without valid Metasploit::Model::MOdule::Rank#name' do
          let(:minimum_rank) do
            'InvalidRank'
          end

          it { should == 0 }
        end
      end

      context 'without MinimumRank' do
        let(:minimum_rank) do
          nil
        end

        it { should == 0 }
      end
    end

    context 'without #framework' do
      before(:each) do
        allow(command).to receive(:framework).and_return(nil)
      end

      it { should == 0 }
    end
  end

  it_should_behave_like 'delegates to #metasploit_instance', :module_type

  context '#nop_class_reference_name' do
    subject(:nop_class_reference_name) do
      command.nop_class_reference_name
    end

    before(:each) do
      metasploit_instance.datastore['NOP'] = nop
    end

    context 'with NOP' do
      let(:nop) do
        'nop/reference/name'
      end

      it 'uses NOP' do
        expect(nop_class_reference_name).to eq(nop)
      end
    end

    context 'without NOP' do
      let(:nop) do
        nil
      end

      it { should be_nil }
    end
  end

  context '#payload_class_reference_name' do
    subject(:payload_class_reference_name) do
      command.payload_class_reference_name
    end

    before(:each) do
      metasploit_instance.datastore['PAYLOAD'] = payload
    end

    context 'with PAYLOAD' do
      let(:payload) do
        'payload/class/reference/name'
      end

      it 'uses PAYLOAD' do
        expect(payload_class_reference_name).to eq(payload)
      end
    end

    context 'without PAYLOAD' do
      let(:payload) do
        nil
      end

      it 'uses #default_payload_class_reference_name' do
        expected = double('#default_payload_class_reference_name')
        expect(command).to receive(:default_payload_class_reference_name).and_return(expected)
        expect(payload_class_reference_name).to eq(expected)
      end
    end
  end

  context '#payload_compatibility' do
    subject(:payload_compatibility) do
      command.send(:payload_compatibility)
    end

    it 'uses #payload_compatibility on #metasploit_instance by passing #target_name as :target_name' do
      target_name = double('#target_name')
      allow(command).to receive(:target_name).and_return(target_name)
      expect(metasploit_instance).to receive(:payload_compatibility).with(
                                         hash_including(
                                             target_name: target_name
                                         )
                                     )

      payload_compatibility
    end
  end

  it_should_behave_like 'delegates to #metasploit_instance', :rank_number

  context '#run_with_valid' do
    subject(:run_with_valid) do
      command.send(:run_with_valid)
    end

    it 'calls #exploit_simple on #metapsloit_instance' do
      expect(metasploit_instance).to receive(:exploit_simple)

      run_with_valid
    end

    context 'exploit_simple' do
      context 'arguments' do
        it "passes #encoder_class_reference_name as 'Encoder'" do
          encoder_class_reference_name = double('#encoder_class_reference_name')
          allow(command).to receive(:encoder_class_reference_name).and_return(encoder_class_reference_name)

          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'Encoder' => encoder_class_reference_name
                                             )
                                         )

          run_with_valid
        end

        it "passes dispatcher.input as 'LocalInput'" do
          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'LocalInput' => dispatcher.input
                                             )
                                         )

          run_with_valid
        end

        it "passes dispatcher.output as 'LocalOutput'" do
          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'LocalOutput' => dispatcher.output
                                             )
                                         )

          run_with_valid
        end

        it "passes #nop_class_reference_name as 'Nop'" do
          nop_class_reference_name = double('#nop_class_reference_name')
          allow(command).to receive(:nop_class_reference_name).and_return(nop_class_reference_name)

          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'Nop' => nop_class_reference_name
                                             )
                                         )

          run_with_valid
        end

        it "passes Metasploit::Framework::Module::Instance::Hosts#local as 'Options' => 'LHOST'" do
          hosts = Metasploit::Framework::Module::Instance::Hosts.new(metasploit_instance: metasploit_instance)

          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'Options' => hash_including(
                                                     'LHOST' => hosts.local
                                                 )
                                             )
                                         )

          run_with_valid
        end

        it "passes #option merged into 'Options'" do
          options = {
              'command' => 'line',
              'options' => 'to',
              'be' => 'merged'
          }
          command.options = options

          expect(metasploit_instance).to receive(:exploit_simple) do |exploit_simple_options|
            actual_options = exploit_simple_options['Options']

            expect(actual_options).to be_a Hash

            options.each do |key, value|
              expect(actual_options[key]).to eq(value)
            end

            nil
          end

          run_with_valid
        end

        it "passes #payload_class_reference_name as 'Payload'" do
          payload_class_reference_name = double('#payload_class_reference_name')
          allow(command).to receive(:payload_class_reference_name).and_return(payload_class_reference_name)

          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'Payload' => payload_class_reference_name
                                             )
                                         )

          run_with_valid
        end

        it "passes job? as 'RunAsJob'" do
          job = double('#job?')
          allow(command).to receive(:job?).and_return(job)

          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 'RunAsJob' => job
                                             )
                                         )

          run_with_valid
        end

        it 'passes #target_name as :target_name' do
          target_name = double('#target_name')
          allow(command).to receive(:target_name).and_return(target_name)

          expect(metasploit_instance).to receive(:exploit_simple).with(
                                             hash_including(
                                                 target_name: target_name
                                             )
                                         )

          run_with_valid
        end
      end

      context 'exceptions' do
        before(:each) do
          expect(metasploit_instance).to receive(:exploit_simple).and_raise(exception)
        end

        context 'with Interrupt' do
          let(:exception) do
            Interrupt.new
          end

          it 'reraises Interrupt so user can interrupt long-running exploit attempts' do
            expect {
              run_with_valid
            }.to raise_error(exception)
          end
        end

        context 'without Interrupt' do
          include_context 'output'

          context 'with Msf::OptionValidateError' do
            let(:exception) do
              Msf::OptionValidateError.new
            end

            it 'does not print call stack' do
              expect(output).not_to include('Call stack:')
            end
          end

          context 'without Msf::OptionValidateError' do
            let(:exception) do
              NameError.new("unknown name", 'name')
            end

            it 'prints call stack' do
              expect(output).to include('Call stack:')
            end
          end
        end
      end

      context 'returned session' do
        before(:each) do
          allow(metasploit_instance).to receive(:exploit_simple).and_return(session)
        end

        context 'with nil' do
          #
          # lets
          #

          let(:session) do
            nil
          end

          #
          # Callbacks
          #

          before(:each) do
            command.job = job
          end

          context 'with job' do
            let(:job) do
              true
            end

            before(:each) do
              metasploit_instance.job_id = job_id
            end

            context 'with job_id' do
              let(:job_id) do
                1
              end

              it 'prints exploit running as background job' do
                expect(output).to include('Exploit running as background job.')
              end
            end

            context 'without job_id' do
              let(:job_id) do
                nil
              end

              it 'does not print exploit running as background job' do
                expect(output).not_to include('Exploit running as backgroudn job.')
              end
            end
          end

          context 'without job' do
            #
            # lets
            #

            let(:job) do
              false
            end

            #
            # Callbacks
            #

            before(:each) do
              metasploit_instance.datastore['DisablePayloadHandler'] = disable_payload_handler
            end

            context 'with DisablePayloadHandler' do
              let(:disable_payload_handler) do
                true
              end

              it 'does not print that no session was created' do
                expect(output).not_to include('Exploit completed, but no session was created.')
              end
            end

            context 'without DisablePayloadHandler' do
              let(:disable_payload_handler) do
                false
              end

              it 'prints that no session was created' do
                expect(output).to include('Exploit completed, but no session was created.')
              end
            end
          end
        end

        context 'without nil' do
          #
          # lets
          #

          let(:session) do
            double('Msf::Session', sid: session_id)
          end

          let(:session_id) do
            '5355102'
          end

          #
          # Callbacks
          #

          before(:each) do
            command.background = background
          end

          context 'with background' do
            let(:background) do
              true
            end

            it 'prints that session with id was created in the background' do
              expect(output).to include("Session #{session_id} created in the background.")
            end
          end

          context 'without background' do
            let(:background) do
              false
            end

            before(:each) do
              allow(session).to receive(:interactive?).and_return(interactive)
            end

            context 'with interactive session' do
              let(:interactive) do
                true
              end

              it 'uses sessions command to make the session interactive' do
                expect(msf_ui_console_driver).to receive(:run_single).with("sessions -q -i #{session_id}")

                run_with_valid
              end
            end

            context 'without interactive session' do
              include_context 'output'

              let(:interactive) do
                false
              end

              it 'leaves the session in the background' do
                expect(msf_ui_console_driver).not_to receive(:run_single).with("sessions -q -i #{session_id}")

                quietly
              end
            end
          end
        end
      end
    end
  end

  context '#target_name' do
    subject(:target_name) do
      command.target_name
    end

    before(:each) do
      metasploit_instance.datastore['TARGET_NAME'] = data_store_target_name
    end

    context 'with TARGET_NAME' do
      let(:data_store_target_name) do
        'Target Name'
      end

      it 'uses TARGET_NAME' do
        expect(target_name).to eq(data_store_target_name)
      end
    end

    context 'without TARGET_NAME' do
      let(:data_store_target_name) do
        nil
      end

      it { should be_nil }
    end
  end
end