##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking

  #
  # This module does basically nothing
  # NOTE: Because of this it's missing a disclosure date that makes msftidy angry.
  #

  def initialize(info = {})
    super(
        Msf::Module::ModuleInfo.update!(
            info,
            'Name'           => 'Generic Payload Handler',
            'Description'    => %q{
              This module is a stub that provides all of the
              features of the Metasploit payload system to exploits
              that have been launched outside of the framework.
            },
            'License'        => MSF_LICENSE,
            'Author'         =>  ['hdm'],
            'References'     =>  [
                # a reference to meet the requirement that all exploits require a reference
                [
                    'URL',
                    'https://www.rapid7.com/db/modules/exploit/multi/handler'
                ]
            ],
            'Payload'        =>
                {
                    'Space'       => 10000000,
                    'BadChars'    => '',
                    'DisableNops' => true,
                },
            'Platform'       => [
                'Android',
                'BSD',
                'Javascript',
                'Java',
                'Linux',
                'NodeJS',
                'OSX',
                'PHP',
                'Python',
                'Ruby',
                'Solaris',
                'UNIX',
                'Windows'
            ],
            'Arch'           => ARCH_ALL,
            'Targets'        => [ [ 'Wildcard Target', { } ] ],
            'DefaultTarget'  => 0
        )
    )

    register_advanced_options(
      [
        OptBool.new("ExitOnSession", [ false, "Return from the exploit after a session has been created", true ]),
        OptInt.new("ListenerTimeout", [ false, "The maximum number of seconds to wait for new sessions", 0])
      ], self.class)
  end

  def exploit
    exit_on_session = data_store['ExitOnSession']

    unless exit_on_session || job_id
      fail_with(Msf::Module::Failure::Unknown, "Setting ExitOnSession to false requires running as a job (exploit -j)")
    end

    listener_timeout = data_store['ListenerTimeout'].to_i
    end_time = nil

    if listener_timeout > 0
      start_time = Time.now
      end_time = start_time + listener_timeout
    end

    print_status "Starting the payload handler..."

    until exit_on_session && session_created?
      if end_time && Time.now > end_time
        fail_with(Msf::Module::Failure::TimeoutExpired, "#{listener_timeout} second timeout expired")
      end

      Rex.sleep(1)
    end
  end
end
