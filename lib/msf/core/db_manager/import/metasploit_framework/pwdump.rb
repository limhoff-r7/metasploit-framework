module Msf::DBManager::Import::MetasploitFramework::Pwdump
  #
  # Metasploit PWDump Export
  #
  # This file format is generated by the db_export -f pwdump and
  # the Metasploit Express and Pro report types of "PWDump."
  #
  # This particular block scheme is temporary, since someone is
  # bound to want to import gigantic lists, so we'll want a
  # stream parser eventually (just like the other non-nmap formats).
  #
  # The file format is:
  # # 1.2.3.4:23/tcp (telnet)
  # username password
  # user2 p\x01a\x02ss2
  # <BLANK> pass3
  # user3 <BLANK>
  # smbuser:sid:lmhash:nthash:::
  #
  # Note the leading hash for the host:port line. Note also all usernames
  # and passwords must be in 7-bit ASCII (character sequences of "\x01"
  # will be interpolated -- this includes spaces, which must be notated
  # as "\x20". Blank usernames or passwords should be <BLANK>.
  #
  def import_msf_pwdump(args={}, &block)
    data = args[:data]
    wspace = args[:wspace] || workspace
    bl = validate_ips(args[:blacklist]) ? args[:blacklist].split : []
    last_host = nil

    addr  = nil
    port  = nil
    proto = nil
    sname = nil
    ptype = nil
    active = false # Are there cases where imported creds are good? I just hate trusting the import right away.

    data.each_line do |line|
      case line
        when /^[\s]*#/ # Comment lines
          if line[/^#[\s]*([0-9.]+):([0-9]+)(\x2f(tcp|udp))?[\s]*(\x28([^\x29]*)\x29)?/n]
            addr = $1
            port = $2
            proto = $4
            sname = $6
          end
        when /^[\s]*Warning:/
          # Discard warning messages.
          next

        # SMB Hash
        when /^[\s]*([^\s:]+):[0-9]+:([A-Fa-f0-9]+:[A-Fa-f0-9]+):[^\s]*$/
          user = ([nil, "<BLANK>"].include?($1)) ? "" : $1
          pass = ([nil, "<BLANK>"].include?($2)) ? "" : $2
          ptype = "smb_hash"

        # SMB Hash
        when /^[\s]*([^\s:]+):([0-9]+):NO PASSWORD\*+:NO PASSWORD\*+[^\s]*$/
          user = ([nil, "<BLANK>"].include?($1)) ? "" : $1
          pass = ""
          ptype = "smb_hash"

        # SMB Hash with cracked plaintext, or just plain old plaintext
        when /^[\s]*([^\s:]+):(.+):[A-Fa-f0-9]*:[A-Fa-f0-9]*:::$/
          user = ([nil, "<BLANK>"].include?($1)) ? "" : $1
          pass = ([nil, "<BLANK>"].include?($2)) ? "" : $2
          ptype = "password"

        # Must be a user pass
        when /^[\s]*([\x21-\x7f]+)[\s]+([\x21-\x7f]+)?/n
          user = ([nil, "<BLANK>"].include?($1)) ? "" : dehex($1)
          pass = ([nil, "<BLANK>"].include?($2)) ? "" : dehex($2)
          ptype = "password"
        else # Some unknown line not broken by a space.
          next
      end

      next unless [addr,port,user,pass].compact.size == 4
      next unless ipv46_validator(addr) # Skip Malformed addrs
      next unless port[/^[0-9]+$/] # Skip malformed ports
      if bl.include? addr
        next
      else
        yield(:address,addr) if block and addr != last_host
        last_host = addr
      end

      cred_info = {
          :host      => addr,
          :port      => port,
          :user      => user,
          :pass      => pass,
          :type      => ptype,
          :workspace => wspace,
          :task      => args[:task]
      }
      cred_info[:proto] = proto if proto
      cred_info[:sname] = sname if sname
      cred_info[:active] = active

      report_auth_info(cred_info)
      user = pass = ptype = nil
    end
  end

  private

  # If hex notation is present, turn them into a character.
  def dehex(str)
    hexen = str.scan(/\x5cx[0-9a-fA-F]{2}/n)
    hexen.each { |h|
      str.gsub!(h,h[2,2].to_i(16).chr)
    }
    return str
  end
end