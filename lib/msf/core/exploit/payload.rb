module Msf::Exploit::Payload
  require 'msf/core/exploit/payload/encoder'
  include Msf::Exploit::Payload::Encoder

  require 'msf/core/exploit/payload/generation'
  include Msf::Exploit::Payload::Generation

  require 'msf/core/exploit/payload/handler'
  include Msf::Exploit::Payload::Handler

  require 'msf/core/exploit/payload/nop'
  include Msf::Exploit::Payload::Nop

  #
  # Attributes
  #

  # @!attribute [rw] payload
  #   The encoded payload.
  #
  #   @return [Msf::EncodedPayload]
  attr_accessor :payload

  # @!attribute [rw] payload_info
  #   Payloads requirements hash.
  #
  #   @return [Hash]
  attr_accessor :payload_info

  # @!attribute [rw] payload_instance
  #   The active payload instance.
  #
  #   @return [Msf::Payload]
  attr_accessor :payload_instance

  #
  # Methods
  #

  #
  # Return any text that should be appended to the payload.  The payload
  # module is passed so that the exploit can take a guess at architecture
  # and platform if it's a multi exploit.
  #
  def payload_append(explicit_target = nil)
    explicit_target ||= target

    if (explicit_target and explicit_target.payload_append)
      explicit_target.payload_append
    else
      payload_info['Append'] || ''
    end
  end

  #
  # Returns the payload extended options hash which is used to provide
  # a location to store extended information that may be useful to
  # a particular type of payload or mixin.
  #
  def payload_extended_options(explicit_target = nil)
    explicit_target ||= target

    if explicit_target and explicit_target.payload_extended_options
      explicit_target.payload_extended_options
    else
      payload_info['ExtendedOptions']
    end
  end

  #
  # Return any text that should be prepended to the payload.  The payload
  # module is passed so that the exploit can take a guess at architecture
  # and platform if it's a multi exploit.  This automatically takes into
  # account any require stack adjustments.
  #
  def payload_prepend(explicit_target = nil)
    explicit_target ||= target

    if (explicit_target and explicit_target.payload_prepend)
      p = explicit_target.payload_prepend
    else
      p = payload_info['Prepend'] || ''
    end

    stack_adjustment + p
  end

  #
  # Returns the maximum amount of room the exploit has for a payload.
  #
  def payload_space
    unless instance_variable_defined? :@payload_space
      @payload_space = nil
      payload_space = payload_info['Space']

      if payload_space
        @payload_space = payload_space.to_i
      end
    end

    @payload_space
  end


  #
  # This method returns the number of bytes that should be adjusted to the
  # stack pointer prior to executing any code.  The number of bytes to adjust
  # is indicated to the routine through the payload 'StackAdjustment'
  # attribute or through a target's payload 'StackAdjustment' attribute.
  #
  def stack_adjustment
    if target && target.payload_stack_adjustment
      stack_adjustment = target.payload_stack_adjustment
    else
      stack_adjustment = payload_info['StackAdjustment']
    end

    adjusted_stack_pointer = nil

    unless stack_adjustment.nil?
      # Get the architecture for the current target or use the one specific to
      # this exploit
      if target
        architecture_abbreviations = target.architecture_abbreviations
      else
        architecture_abbreviations = self.architecture_abbreviations
      end

      # Default to x86 if we can't find a list of architectures
      if architecture_abbreviations.blank?
        architecture_abbreviations = [ARCH_X86]
      end

      formatted_architecture_abbreviations = architecture_abbreviations.join(', ')

      adjusted_stack_pointer = Rex::Arch::adjust_stack_pointer(formatted_architecture_abbreviations, stack_adjustment)
    end

    adjusted_stack_pointer ||= ''

    adjusted_stack_pointer
  end
end