module Msf::Exploit::Targets
  #
  # Attributes
  #

  # @!attribute [rw] default_target
  #   The default target for this exploit.
  #
  #   @return [String] element of {#targets}.
  attr_accessor :default_target

  # @!attribute [r] targets
  #   The targets for this exploit.
  #
  #   @return [Array<String>]

  #
  # Methods
  #

  # @deprecated Use {#default_target_index} instead.
  # @return (see #default_target_index)
  def default_target
    ActiveSupport::Deprecation.warn "#{self.class}##{__method__} is deprecated.  Use #{self.class}#default_target_index instead"
    default_target_index
  end

  # The index of the default target as declared with 'DefaultTarget' info key passed to initialize.
  #
  # @return [nil] if 'DefaultTarget' not given.
  # @return [Integer] if 'DefaultTarget' given.
  def default_target_index
    # can't use ||= because it may be nil
    unless instance_variable_defined? :@default_target_index
      default_target_index = module_info['DefaultTarget']

      # don't want to cast nil to 0
      unless default_target_index.nil?
        default_target_index = default_target_index.to_i
      end

      @default_target_index = default_target_index
    end

    @default_target_index
  end

  # Returns the active target for this exploit.  If not target has been
  # defined, nil is returned.  If no target was defined but there is a
  # default target, that one will be automatically used.
  def target
    target_idx = target_index

    return (target_idx) ? targets[target_idx.to_i] : nil
  end

  #
  # The target index that has been selected.
  #
  def target_index
    data_store_target_index = data_store['TARGET']
    target_index = nil

    # Use the default target if one was not supplied.
    if data_store_target_index.nil?
      if default_target_index && default_target_index >= 0
        target_index = default_target_index
      end
    else
      target_index = data_store_target_index.to_i
    end

    target_index
  end

  # (see #target_platform_list)
  # @deprecated Use {#target_platform_list}
  def target_platform
    ActiveSupport::Deprecation.warn(
        "#{self.class}##{__method__} is deprecated.  Use #{self.class}#target_platform_list instead"
    )
    target_platform_list
  end

  # Returns the current {#target target's} {Msf::Module::Target::Platforms#platform_list} if there is a {#target};
  # otherwise, fallbacks to this module's {Msf::Module::Platforms#platform_list}.
  #
  # @return [Msf::Module::PlatformList]
  def target_platform_list
    if target
      # a target always has a platform_list because it will use the module platform_list if the target has no
      # declared platform list.
      target.platform_list
    else
      platform_list
    end
  end

  # (see #target_architecture_abbreviations)
  # @deprecated Use {#target_architecture_abbreviations}
  def target_arch
    ActiveSupport::Deprecation.warn(
        "#{self.class}##{__method__} is deprecated.  Use #{self.class}#target_architecture_abbreviations instead"
    )
    target_architecture_abbreviations
  end

  # Returns the current {#target target's} {Msf::Module::Target::Architectures#architecture_abbreviations} if there is a
  # {#target}; otherwise, fallbacks to this module's {Msf::Module::Architectures#architecture_abbreviations}
  #
  # @return [Array<String>] Array of `Metasploit::Model::Architecture#abbreviation`s
  def target_architecture_abbreviations
    if target
      # a target always has architecture_abbreviations because it will use the module architecture_abbreviations if the
      # target has no declared architecture abbreviations
      target.architecture_abbreviations
    else
      architecture_abbreviations
    end
  end

  def targets
    unless instance_variable_defined? :@targets
      targets = Rex::Transformer.transform(
          module_info['Targets'],
          Array,
          [
              Msf::Module::Target
          ],
          'Targets'
      )

      # assign metasploit_instance so that target can delegate to it for architecture_abbreviations and platform_list
      targets.each do |target|
        target.metasploit_instance = self
      end

      @targets = targets
    end

    @targets
  end
end