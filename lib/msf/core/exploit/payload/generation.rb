module Msf::Exploit::Payload::Generation
  #
  # Generates the encoded version of the supplied payload using the payload
  # requirements specific to this exploit.  The encoded instance is returned
  # to the caller.  This method is exposed in the manner that it is such
  # that passive exploits and re-generate an encoded payload on the fly
  # rather than having to use the pre-generated one.
  #
  # The return value is an EncodedPayload instance.
  #
  def generate_payload(payload_instance = nil)
    payload_instance ||= self.payload_instance
    # Set the encoded payload to the result of the encoding process
    self.payload = generate_single_payload(payload_instance: payload_instance)

    # Save the payload instance
    self.payload_instance = payload_instance

    payload
  end

  # Generates a non-cached payload which is typically useful for passive exploits that will have more than one client.
  #
  # @param options [Hash{Symbol => Object}]
  # @option options [Array<String>] :architecture_abbreviations Array of `Mdm::Architecture#abbreviation`.
  # @option options [Msf::Payload] :payload_instance (#payload_instance) Msf::Payload whose {Msf::Payload#assembly} to
  #   turn into assembled shell code.
  # @option options [Msf::Module::PlatformList] :platform_list List of platforms that the assembled shell code needs to
  #   support.
  # @option options [Msf::Module::Target] :target (Msf::Exploit::Targets#target) The target to use instead of
  #   {Msf::Exploit::Targets#target}.
  # @return (see #encode_end)
  def generate_single_payload(options={})
    options.assert_valid_keys(:architecture_abbreviations, :payload_instance, :platform_list, :target)

    target = options.fetch(:target, self.target)

    unless target
      raise MissingTargetError, "No target has been specified."
    end

    payload_instance = options[:payload_instance] || self.payload_instance

    unless payload_instance
      raise MissingPayloadError, "No payload has been selected."
    end

    # If this is a generic payload, then we should specify the platform
    # and architecture so that it knows how to pass things on.
    if payload_instance.kind_of?(Msf::Payload::Generic)
      platform_list = options.fetch(:platform_list) { target.platform_list }

      if platform_list
        payload_instance.explicit_platform_list = platform_list
      end

      architecture_abbreviations = options.fetch(:architecture_abbreviations) { target.architecture_abbreviations }

      if architecture_abbreviations
        payload_instance.explicit_architecture_abbreviations = architecture_abbreviations
      end

      # Force it to reset so that it will find updated information.
      payload_instance.reset
    end

    # Duplicate the exploit payload requirements
    reqs = payload_info.dup

    # Pass save register requirements to the NOP generator
    reqs['Space']           = target.payload_space
    reqs['SaveRegisters']   = target.save_registers
    reqs['Prepend']         = payload_prepend(target)
    reqs['PrependEncoder']  = payload_prepend_encoder(target)
    reqs['BadChars']        = payload_badchars(target)
    reqs['Append']          = payload_append(target)
    reqs['AppendEncoder']   = payload_append_encoder(target)
    reqs['MaxNops']         = payload_max_nops(target)
    reqs['MinNops']         = payload_min_nops(target)
    reqs['Encoder']         = data_store['ENCODER']
    reqs['Nop']             = data_store['NOP']
    reqs['EncoderType']     = payload_encoder_type(target)
    reqs['EncoderOptions']  = payload_encoder_options(target)
    reqs['ExtendedOptions'] = payload_extended_options(target)
    reqs['Exploit']         = self

    # Pass along the encoder don't fall through flag
    reqs['EncoderDontFallThrough'] = data_store['EncoderDontFallThrough']

    # Incorporate any context encoding requirements that are needed
    define_context_encoding_reqs(reqs)

    # Call the encode begin routine.
    encode_begin(payload_instance, reqs)

    # Generate the encoded payload.
    encoded = Msf::EncodedPayload.create(payload_instance, reqs)

    # Call the encode end routine which is expected to return the actual
    # encoded payload instance.
    return encode_end(payload_instance, reqs, encoded)
  end

  # Re-generates an encoded payload, typically called after something in the
  # data_store has changed.  An optional platform and architecture can be
  # supplied as well.
  #
  # @param options (see #generate_single_payload)
  # @option options :architecture_abbreviations (see #generate_single_payload)
  # @option options :platform_list (see #generate_single_payload)
  # @option options :target (see #generate_single_payload)
  # @return (see #generate_single_payload)
  def regenerate_payload(options={})
    options.assert_valid_keys(:architecture_abbreviations, :platform_list, :target)

    generate_single_payload(options)
  end

  # Give exploits the ability to use the original +regenerate_payload+ so
  # they can avoid needing additional arguments added by overridden versions.
  # Used specifically by things that include +TcpServer+ (or a descendant)
  # but which are active exploits.
  alias :exploit_regenerate_payload :regenerate_payload

  protected

  #
  # Gets the memory map file and other context information that is
  # required when wanting to support context keyed encoding
  #
  def define_context_encoding_reqs(reqs)
    return if data_store['EnableContextEncoding'] != true

    # At present, we don't support any automatic methods of obtaining
    # context information.  In the future, we might support obtaining
    # temporal information remotely.

    # Pass along the information specified in our exploit data_store as
    # encoder options
    reqs['EncoderOptions'] = {} if reqs['EncoderOptions'].nil?
    reqs['EncoderOptions']['EnableContextEncoding']  = data_store['EnableContextEncoding']
    reqs['EncoderOptions']['ContextInformationFile'] = data_store['ContextInformationFile']
  end

  #
  # Called prior to encoding a payload.
  #
  def encode_begin(real_payload, reqs)
  end

  # Called after an encoded payload has been generated.  This gives exploits
  # or mixins a chance to alter the encoded payload.
  #
  # @param encoded [Msf::EncodedPayload]
  # @return [Msf::EncodedPayload] encoded with any modifications
  def encode_end(real_payload, reqs, encoded)
    encoded
  end
end