# -*- coding: binary -*-

###
#
# This module exposes a simple method to create an payload in an executable.
#
###

module Msf
module Exploit::EXE

  def initialize(info = {})
    super

    # NOTE: Any new options here should also be dealt with in
    # EncodedPayload#encoded_exe in lib/msf/core/encoded_payload.rb
    register_advanced_options(
      [
        OptPath.new(   'EXE::Custom',   [ false, 'Use custom exe instead of automatically generating a payload exe']),
        OptPath.new(   'EXE::Path',     [ false, 'The directory in which to look for the executable template' ]),
        OptPath.new(   'EXE::Template', [ false, 'The executable template file name.' ]),
        OptBool.new(   'EXE::Inject',   [ false, 'Set to preserve the original EXE function' ]),
        OptBool.new(   'EXE::OldMethod',[ false, 'Set to use the substitution EXE generation method.' ]),
        OptBool.new(   'EXE::FallBack', [ false, 'Use the default template in case the specified one is missing' ]),
        OptPath.new(   'MSI::Custom',   [ false, 'Use custom msi instead of automatically generating a payload msi']),
        OptPath.new(   'MSI::Path',     [ false, 'The directory in which to look for the msi template' ]),
        OptPath.new(   'MSI::Template', [ false, 'The msi template file name' ]),
        OptBool.new(   'MSI::UAC',      [ false, 'Create an MSI with a UAC prompt (elevation to SYSTEM if accepted)' ])
      ], self.class)
  end

  def get_custom_exe(path=nil)
    path ||= datastore['EXE::Custom']
    print_status("Using custom payload #{path}, RHOST and RPORT settings will be ignored!")
    datastore['DisablePayloadHandler'] = true

    file = ::File.open(path,'rb')
    exe = file.read(file.stat.size)
    file.close
    exe
  end

  # @param options [Hash{Symbol => Object}]
  # @option options
  def generate_payload_exe(options={})
    return get_custom_exe if data_store.include? 'EXE::Custom'

    options.assert_valid_keys(:architecture_abbreviations, :code, :platforms)

    merged_options = merge_exe_options(options)

    code = merged_options[:code]
    code ||= payload.encoded

    # Fall back to x86...
    architecture_abbreviations = Array.wrap(merged_options[:architecture_abbreviations])

    if architecture_abbreviations.empty?
      architecture_abbreviations = [ ARCH_X86 ]
    end

    exe = Msf::Util::EXE.to_executable(
        merged_options.merge(
            architecture_abbreviations: architecture_abbreviations,
            code: code,
            framework: framework
        )
    )
    exe_post_generation(merged_options)
    exe
  end

  def generate_payload_exe_service(options = {})
    return get_custom_exe if data_store.include? 'EXE::Custom'

    merged_options = merge_exe_options(options)

    # NOTE: Only Windows is supported here.
    pl = merged_options[:code]
    pl ||= payload.encoded

    merged_options[:arch] = Array.wrap(merged_options[:arch])

    if merged_options[:arch].include? ARCH_X86_64
      exe = Msf::Util::EXE.to_win64pe_service(framework, pl, merged_options)
    else
      exe = Msf::Util::EXE.to_win32pe_service(framework, pl, merged_options)
    end

    exe_post_generation(merged_options)
    exe
  end

  def generate_payload_dll(options = {})
    return get_custom_exe if data_store.include? 'EXE::Custom'

    merged_options = merge_exe_options(options)

    # NOTE: Only Windows is supported here.
    pl = merged_options[:code]
    pl ||= payload.encoded

    merged_options[:arch] = Array.wrap(merged_options[:arch])

    if merged_options[:arch].include? ARCH_X86_64
      dll = Msf::Util::EXE.to_win64pe_dll(framework, pl, merged_options)
    else
      dll = Msf::Util::EXE.to_win32pe_dll(framework, pl, merged_options)
    end

    exe_post_generation(merged_options)
    dll
  end

  def generate_payload_msi(opts = {})
    return get_custom_exe(datastore['MSI::Custom']) if datastore.include? 'MSI::Custom'

    exe = generate_payload_exe(opts)

    opts.merge! ({
        :msi_template => datastore['MSI::Template'],
        :msi_template_path => datastore['MSI::Path'],
        :uac => datastore['MSI::UAC']
    })

    msi = Msf::Util::EXE.to_exe_msi(framework, exe, opts)

    return msi
  end

  # Merges values from {Msf::Module#datastore} and {Msf::Module#module_info} into `options` to be passed to
  # Msf::Util::Exe methods.
  #
  # @param options [Hash] options to add default options from this module and its data_store.
  # @return [Hash] Copy of `options` with {Msf::Module#data_store} and defaults merged.
  def merge_exe_options(options={})
    merged_options = options.merge(
        fallback: data_store['EXE::FallBack'],
        inject: data_store['EXE::Inject'],
        sub_method: data_store['EXE::OldMethod'],
        template: data_store['EXE::Template'],
        template_path: data_store['EXE::Path']
    )

    platforms = options[:platforms]

    unless platforms
      # Prefer the target's platform/architecture information, but use
      # the module's if no target specific information exists
      if respond_to? :target_platform_list
        platforms = target_platform_list.platforms
      end

      if platforms.nil? && respond_to?(:platform_list)
        platforms = platform_list.platforms
      end

      merged_options[:platforms] = platforms
    end

    architecture_abbreviations = options[:architecture_abbreviations]

    unless architecture_abbreviations
      if respond_to? :target_architecture_abbreviations
        architecture_abbreviations = target_architecture_abbreviations
      end

      if architecture_abbreviations.nil? && respond_to?(:architecture_abbreviations)
        architecture_abbreviations = self.architecture_abbreviations
      end

      merged_options[:architecture_abbreviations] = architecture_abbreviations
    end

    merged_options
  end

protected

  def exe_post_generation(options)
    if (options[:fellback])
      print_status("Warning: Falling back to default template: #{options[:fellback]}")
    end
  end

end
end
