# -*- coding: binary -*-

###
#
# This module exposes a simple method to create an payload in an executable.
#
###

module Msf
module Exploit::EXE

  def initialize(info = {})
    super

    # NOTE: Any new options here should also be dealt with in
    # EncodedPayload#encoded_exe in lib/msf/core/encoded_payload.rb
    register_advanced_options(
      [
        OptPath.new(   'EXE::Custom',   [ false, 'Use custom exe instead of automatically generating a payload exe']),
        OptPath.new(   'EXE::Path',     [ false, 'The directory in which to look for the executable template' ]),
        OptPath.new(   'EXE::Template', [ false, 'The executable template file name.' ]),
        OptBool.new(   'EXE::Inject',   [ false, 'Set to preserve the original EXE function' ]),
        OptBool.new(   'EXE::OldMethod', [ false, 'Set to use the substitution EXE generation method.' ]),
        OptBool.new(   'EXE::FallBack', [ false, 'Use the default template in case the specified one is missing' ])
      ], self.class)
  end

  def get_custom_exe
    print_status("Using custom executable #{data_store["EXE::Custom"]}, RHOST and RPORT settings will be ignored!")
    data_store['DisablePayloadHandler'] = true
    file = ::File.open(data_store['EXE::Custom'],'rb')
    exe = file.read(file.stat.size)
    file.close
    exe
  end

  # @param options [Hash{Symbol => Object}]
  # @option options
  def generate_payload_exe(options={})
    return get_custom_exe if data_store.include? 'EXE::Custom'

    options.assert_valid_keys(:architecture_abbreviations, :code, :platforms)

    exe_init_options(options)

    code = options[:code]
    code ||= payload.encoded

    # Fall back to x86...
    architecture_abbreviations = Array.wrap(options[:architecture_abbreviations])

    if architecture_abbreviations.empty?
      architecture_abbreviations = [ ARCH_X86 ]
    end

    exe = Msf::Util::EXE.to_executable(
        options.merge(
            architecture_abbreviations: architecture_abbreviations,
            code: code,
            framework: framework
        )
    )
    exe_post_generation(options)
    exe
  end

  def generate_payload_exe_service(opts = {})
    return get_custom_exe if data_store.include? 'EXE::Custom'

    exe_init_options(opts)

    # NOTE: Only Windows is supported here.
    pl = opts[:code]
    pl ||= payload.encoded

    if opts[:arch] && opts[:arch] == ARCH_X86_64
      exe = Msf::Util::EXE.to_win64pe_service(framework, pl, opts)
    else
      exe = Msf::Util::EXE.to_win32pe_service(framework, pl, opts)
    end

    exe_post_generation(opts)
    exe
  end

  def generate_payload_dll(opts = {})
    return get_custom_exe if data_store.include? 'EXE::Custom'

    exe_init_options(opts)

    # NOTE: Only Windows is supported here.
    pl = opts[:code]
    pl ||= payload.encoded

    if opts[:arch] && opts[:arch] == ARCH_X86_64
      dll = Msf::Util::EXE.to_win64pe_dll(framework, pl, opts)
    else
      dll = Msf::Util::EXE.to_win32pe_dll(framework, pl, opts)
    end

    exe_post_generation(opts)
    dll
  end

protected
  # @note Modifies `options`.
  #
  # @param options [Hash] options to add default options from this module and its data_store.
  # @return [void]
  def exe_init_options(options)
    options.merge!(
        fallback: data_store['EXE::FallBack'],
        inject: data_store['EXE::Inject'],
        sub_method: data_store['EXE::OldMethod'],
        template: data_store['EXE::Template'],
        template_path: data_store['EXE::Path']
    )

    platforms = options[:platforms]

    unless platforms
      # Prefer the target's platform/architecture information, but use
      # the module's if no target specific information exists
      if respond_to? :target_platform_list
        platforms = target_platform_list.platforms
      end

      if platforms.nil? && respond_to?(:platform_list)
        platforms = platform_list.platforms
      end

      options[:platforms] = platforms
    end

    architecture_abbreviations = options[:architecture_abbreviations]

    unless architecture_abbreviations
      if respond_to? :target_architecture_abbreviations
        architecture_abbreviations = target_architecture_abbreviations
      end

      if architecture_abbreviations.nil? && respond_to?(:architecture_abbreviations)
        architecture_abbreviations = self.architecture_abbreviations
      end

      options[:architecture_abbreviations] = architecture_abbreviations
    end
  end

  def exe_post_generation(options)
    if (options[:fellback])
      print_status("Warning: Falling back to default template: #{options[:fellback]}")
    end
  end

end
end
