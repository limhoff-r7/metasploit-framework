require 'msf/core/exploit/compat_defaults'

module Msf::Exploit::Compatibility
  include Metasploit::Framework::Module::Class::Logging

  #
  # Returns a list of compatible encoders based on architecture
  #
  def compatible_encoders
    encoders = []

    c_platform = (target and target.platform) ? target.platform : platform
    c_arch     = (target and target.arch)     ? target.arch     : (arch == []) ? nil : arch

    framework.encoders.each_module_ranked(
        'Arch' => c_arch, 'Platform' => c_platform) { |name, mod|

      encoders << [ name, mod ]
    }

    return encoders;
  end

  # @param options [Hash{Symbol => String,Array<String>}]
  # @option options :reference_names (see Msf::Module::Target::Payload#compatible_payload_instances)
  # @option options [String] :target_name The name of the target whose architectures, platforms and payload space to
  #   to use to filter the payloads.  Defaults to current {#target} for this exploit.
  # @return [Metasploit::Framework::Module::Target::Compatibility::Payload]
  # @return [nil] if :target_name does not name a valid target or {Msf::Module::Targets#target} is `nil`
  def payload_compatibility(options={})
    options.assert_valid_keys(:reference_names, :target_name)

    target_name = options[:target_name]

    if target_name
      named_target = targets.find { |target|
        target.name == target_name
      }
    else
      named_target = self.target
    end

    if named_target
      named_target.payload_compatibility(
          reference_names: options[:reference_names]
      )
    else
      nil
    end
  end

  # Returns a list of compatible payloads based on architecture, platform, and size for a given target.  Optionally,
  # restrict the searched set of payload modules to a given set of `Mdm::Module::Class#reference_names`
  #
  # @param options [Hash{Symbol => String,Array<String>}]
  # @option options :reference_names (see Msf::Module::Target::Payload#compatible_payload_instances)
  # @option options [String] :target_name The name of the target whose architectures, platforms and payload space to
  #   to use to filter the payloads.  Defaults to current {#target} for this exploit.
  # @return [Array<Msf::Payload>]  payload instances that are compatible with this exploit.
  def compatible_payload_instances(options={})
    options.assert_valid_keys(:reference_names, :target_name)

    target_name = options[:target_name]

    if target_name
      named_target = targets.find { |target|
        target.name == target_name
      }
    else
      named_target = self.target
    end

    named_target.compatible_payload_instances(
        reference_names: options[:reference_names]
    )
  end

  #
  # Overrides the base class method and serves to initialize default
  # compatibilities for exploits
  #
  def init_compat
    super

    #
    # Merge in payload compatible defaults
    #
    p = module_info['Compat']['Payload']

    Msf::Exploit::CompatDefaults::Payload.each_pair { |k,v|
      (p[k]) ? p[k] << " #{v}" : p[k] = v
    }

    #
    # Set the default save registers if none have been explicitly
    # specified.
    #
    if (module_info['SaveRegisters'] == nil)
      module_info['SaveRegisters'] = [ 'esp', 'ebp' ]
    end
  end
end