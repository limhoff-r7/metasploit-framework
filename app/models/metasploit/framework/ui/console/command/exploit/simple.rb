class Metasploit::Framework::UI::Console::Command::Exploit::Simple < Metasploit::Framework::UI::Console::Command::Base
  include Metasploit::Framework::UI::Console::Command::Child

  #
  # Attributes
  #

  # @!attribute [rw] background
  #   Whether the session should be backgrounded immediately upon success.
  #
  #   @return [true] The session is sent to the background
  #   @return [false] The session is interactive in the foreground.
  attr_writer :background

  # @!attribute [rw] encoder_class_reference_name
  #   The `Mdm::Module::Class#reference_name` of the encoder.
  #
  #   @return [String]
  attr_writer :encoder_class_reference_name

  # @!attribute [rw] force
  #   Force the exploit to run even if its rank is below the minimum rank for the framework's data store.
  #
  #   @return [true] to ignore the minimum rank.
  #   @return [false] to follow the minimum rank.
  attr_writer :force

  # @!attribute [rw] job
  #   Whether to run the exploit as a job.
  #
  #   @return [true] run as a job.
  #   @return [false] run normally.
  attr_writer :job

  # @!attribute [rw] local_host
  #   The IP address of the local host.
  #
  #   @return [String] an IP address.  Defaults to `Rex::Socket.source_address(remote_host)` where `remote_host` is
  #     the `data_store['RHOST']` or '50.50.50.50' as a default, invalid IP address to get the local address.
  attr_writer :local_host

  # @!attribute [rw] nop_class_reference_name
  #   The `Mdm::Module::Class#reference_name` of the nop generator.
  #
  #   @return [String]
  attr_writer :nop_class_reference_name

  # @!attribute [rw] options
  #   Data store options for {#metasploit_instance}, set when calling {#exploit} command using
  #   `--options VAR1=VAL1,VAR2=VAL@`
  #
  #   @return [Hash]
  attr_writer :options

  # @!attribute [rw] payload_class_reference_name
  #   The `Mdm::Module::Class#reference_name` of the payload.
  #
  #   @return [String]
  attr_writer :payload_class_reference_name

  # @!attribute [rw] target_name
  #   The `Mdm::Module::Target#name`.
  #
  #   @return [String]
  attr_writer :target_name

  #
  #
  # Validations
  #
  #

  #
  # Method Validations
  #

  validate :minimum_rank_or_forced

  #
  # Attribute Validations
  #

  validates :dispatcher,
            fanged: true
  validates :metasploit_instance,
            presence: true
  validates :module_type,
            inclusion: {
                in: [
                    'exploit'
                ]
            }
  validates :words,
            length: {
                is: 0
            }

  #
  # Methods
  #

  # Whether the session should be backgrounded immediately upon success.
  #
  # @return [true] The session is sent to the background
  # @return [false] The session is interactive in the foreground.
  def background
    @background ||= false
  end

  # Same as {#background}, but guaranteed to return a Boolean.
  #
  # @return (see #background)
  def background?
    !!background
  end

  # The encoder `Mdm::Module::Class#reference_name` set in `ENCODER` for {#metasploit_instance.}
  #
  # @return [String] an {Mdm::Module::Class#reference_name}.  {Mdm::Module::Class#module_type} is assumed to be 'encoder'
  #   for the {Mdm::Module::Class#full_name}.
  def encoder_class_reference_name
    @encoder_class_reference_name ||= metasploit_instance.data_store['ENCODER']
  end

  # Force the exploit to run even if its rank is below the minimum rank for the framework's {Msf::Framework#data_store}.
  #
  # @return [true] to ignore the minimum rank.
  # @return [false] to follow the minimum rank.
  def force
    @force ||= false
  end

  # Same as {#force}, but guaranteed to return a Boolean.
  #
  # @return (see #force)
  def force?
    !!force
  end

  # @!method framework
  #   @return (see Metasploit::Framework::UI::Console::Command::Exploit#framework)
  #
  # @!method metasploit_instance
  #   The current used metasploit instance.
  #
  #   @return (see Metasploit::Framework::UI::Console::Command::Exploit#metasploit_instance)
  delegate :framework,
           :metasploit_instance,
           allow_nil: true,
           to: :parent

  # Whether to run the exploit as a job.
  #
  # @return [true] run as a job.  Automatically true if metasploit_instance is passive.
  # @return [false] run normally.
  def job
    unless instance_variable_defined? :@job
      # Allows run passive exploits as jobs so user doesn't have to wait for connection.
      if metasploit_instance && metasploit_instance.respond_to?(:passive?) && metasploit_instance.passive?
        @job = true
      else
        @job = false
      end
    end

    @job
  end

  # Same as {#job}, but guarenteed to be Boolean.
  #
  # @return [Boolean]
  def job?
    !!job
  end

  # @!method module_type
  #   The {Msf::Module::Type#module_type} of {#metasploit_instance}.
  #
  #   @return (see Msf::Module::Type#module_type)
  #
  # @!method rank_number
  #   The {Msf::Module::Rank#rank_number} of {#metasploit_instance}.
  #
  #   @return (see Msf::Module::Rank#rank_number)
  delegate :module_type,
           :rank_number,
           allow_nil: true,
           to: :metasploit_instance

  # The `Mdm::Module::Class#reference_name` for the nop generator set in `NOP` for {#metasploit_instance}.
  #
  # @return [String] an `Mdm::Module::Class#reference_name`.  The `Mdm::Module::Class#module_type` is assumed to `nop`
  #   for the `Mdm::Module::Class#full_name`.
  def nop_class_reference_name
    @nop_class_reference_name ||= metasploit_instance.data_store['NOP']
  end

  # Additional data store options to pass to {#metasploit_instance}.
  #
  # @return [Hash]
  def options
    @options ||= {}
  end

  # The `Mdm::Module::Class#reference_name` for the payload set in `PAYLOAD` for {#metasploit_instance}.  If `PAYLOAD`
  #   is not set, then {#default_payload_class_reference_name} is used.
  #
  # @return [String] an `Mdm::Module::Class#reference_name`.  The `Mdm::Module::Class#module_type` is assumed to
  #   `payload` for the `Mdm::Module::Class#full_name`.
  def payload_class_reference_name
    unless instance_variable_defined? :@payload_class_reference_name
      payload_class_reference_name = metasploit_instance.data_store['PAYLOAD']

      unless payload_class_reference_name
        payload_class_reference_name = default_payload_class_reference_name
      end

      @payload_class_reference_name = payload_class_reference_name
    end

    @payload_class_reference_name
  end

  # The name of the {Mdm::Module::Target#name}.  Uses `TARGET_NAME` for {#metasploit_instance}.
  #
  # @return [String] an {Mdm::Module::Target#name} or {Msf::Module::Target#name}
  def target_name
    @target_name ||= metasploit_instance.data_store['TARGET_NAME']
  end

  protected

  # Launches exploit using {Msf::Simple::Exploit#exploit_simple} on {#metasploit_instance}.  Allow for interrupts and
  # handles logging all other exceptions.  If {Msf::Simple::Exploit#exploit_simple} sucessfully returns a session, it
  # is made interactive unless {#background} is `true`.
  #
  # @return [void]
  def run_with_valid
    begin
      session = metasploit_instance.exploit_simple(
          'Encoder'      => encoder_class_reference_name,
          'LocalInput'   => dispatcher.input,
          'LocalOutput'  => dispatcher.output,
          'Nop'          => nop_class_reference_name,
          'Options'      => merged_options,
          'Payload'      => payload_class_reference_name,
          'RunAsJob'     => job?,
          target_name: target_name
      )
    rescue Interrupt => interrupt
      raise interrupt
    rescue ::Exception => exception
      print_error("Exploit (#{metasploit_instance.reference_name}) exception: #{exception.class} #{exception}")

      unless exception.is_a? Msf::OptionValidateError
        print_error("Call stack:")

        exception.backtrace.each do |line|
          break if line =~ /lib.msf.base.simple/
          print_error("  #{line}")
        end
      end
    end

    # If we were given a session, let's see what we can do with it
    if session
      # If we aren't told to run in the background and the session can be
      # interacted with, start interacting with it by issuing the session
      # interaction command.
      if !background? && session.interactive?
        print_line

        dispatcher.driver.run_single("sessions -q -i #{session.sid}")
      # Otherwise, log that we created a session
      else
        print_status("Session #{session.sid} created in the background.")
      end
    # If we ran the exploit as a job, indicate such so the user doesn't
    # wonder what's up.
    elsif job?
      if metasploit_instance.job_id
        print_status("Exploit running as background job.")
      end
    # Worst case, the exploit ran but we got no session, bummer.
    else
      # If we didn't run a payload handler for this exploit it doesn't
      # make sense to complain to the user that we didn't get a session
      unless metasploit_instance.data_store["DisablePayloadHandler"]
        print_status("Exploit completed, but no session was created.")
      end
    end
  end

  private

  # The default {#payload_class_reference_name}.
  #
  # @return [String] `Mdm::Module::Class#reference_name`.
  # @return [nil] if {#metasploit_instance} is not compatible with any of the default payloads in
  #   {Metasploit::Framework::Module::Target::Compatibility::Payload::DEFAULT_REFERENCE_NAMES}.
  def default_payload_class_reference_name
    if payload_compatibility
      payload_compatibility.preferred_class_reference_name
    else
      nil
    end
  end

  # 'Options' Hash passed to {Msf::Simple::Exploit#exploit_simple}, which includes both the {#options} passed with
  # `--options` to the command and 'LHOST' from {#local_host}, which {Msf::Simple::Exploit#exploit_simple} only supports
  # in the 'Options' Hash.
  #
  # @return [Hash]
  def merged_options
    merged_options = options.dup

    unless options['LHOST']
      hosts = Metasploit::Framework::Module::Instance::Hosts.new(metasploit_instance: metasploit_instance)
      hosts.valid!

      merged_options['LHOST'] = hosts.local
    end

    merged_options
  end

  # The minimum {Msf::Module::Rank#rank_number} that {#metasploit_instance} can have if it is to be valid for exploit.
  # Uses `MinimumRank` set on the {#framework}. {Msf::Module::Rank#rank_number} below this value can be forced to
  # exploit by setting {#force} with the `--force` option.
  #
  # @return [Integer] `Metasploit::Model::Module::Rank::NUMBER_BY_NAME` value
  # @return [0] if `MinimumRank` is not set
  def minimum_rank_number
    unless instance_variable_defined? :@minimum_rank_number
      if framework
        minimum_rank_name = framework.data_store['MinimumRank']
        @minimum_rank_number = Metasploit::Model::Module::Rank::NUMBER_BY_NAME[minimum_rank_name]
      end

      @minimum_rank_number ||= 0
    end

    @minimum_rank_number
  end

  # Validate that if {#rank_number} is present, then it is greater than or equal to {#minimum_rank_number} or the
  # exploit is being {#force? forced}.
  #
  # @return [void]
  def minimum_rank_or_forced
    if rank_number && rank_number < minimum_rank_number && !force?
      minimum_rank_name = Metasploit::Model::Module::Rank::NAME_BY_NUMBER[minimum_rank_number]
      rank_name = Metasploit::Model::Module::Rank::NAME_BY_NUMBER[rank_number]

      errors.add(
          :rank_number,
          :minimum_rank,
          minimum_rank_name: minimum_rank_name,
          minimum_rank_number: minimum_rank_number,
          rank_name: rank_name,
          rank_number: rank_number
      )
    end
  end

  # {Metasploit::Framework::Module::Target::Compatibility::Payload} for target with {#target_name} on
  # {#metasploit_instance}.
  #
  # @return [Metasploit::Framework::Module::Target::Compatibility::Payload]
  def payload_compatibility
    @payload_compatibility ||= metasploit_instance.payload_compatibility(target_name: target_name)
  end
end
